>Crypto


# MD5



# RSA

## Given p and q. find n ? find totient(n)? find d?
```
q : 93187
p : 94603
```
> from Crypto.Util.number import *
> `n = p * q` ,so "8815769761" 
> `totient(n)= phiN = (p-1)*(q-1)`
> d = inverse(e,phiN)

## Plaintext,e and n into cipherText
```
plaintext : "THISISATESTOFTHEGIANTMADLIBSYSTEMISAYAGAINTHISISATESTOFTHEGIANTMADLIBSYSTEMTHISISONLYATEST"
e : 3
n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
```
> `cipher = pow(bytes_to_long(plaintext), e, n)`

## e,n,cipher(bytes) into plainText

```
ciphertext : 1191791154385603989017338950457953706444549348977257175840859024439456896961914986634158747079098646147275076768073561042920214249993651808989837779063107922958105481379936383065215869487850820431171263674544580096729254472650575604484973219990255615863148106543105096126096999191988960394375673790215786843107073528379091019699671260953369425507741892996006226548525831549275670809621483441808393283624850199270699755906043632045064848258791734958759503417667092878170518427857289905497710627257839284785457619198191563756900049939096535179455095450168682853409392860360775357790031928613703963238835882564864599021
e : 65537
n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
```
> http://factordb.com , to try values of p and q from `n`
> if we get `p` and `q`, we can simply decipher by 
	`long_to_bytes(pow(cipher , Crypto.Util.number.inverse(e, (p-1)*(q-1) ) , (p*q)))`	


# AES

## Bit-flipping

## Incorrect padding 


# substitution cipher


# XOR

## xor 2 strings(fixed size, single byte xor , repeating-key)

**Works on both fixed size and variable size ouput. in variable size, it recursively uses small strings .**

`fixed same size`
```
from pwn import *
xor("1c0111001f010100061a024b53535009181c".decode('hex'),"686974207468652062756c6c277320657965".decode('hex')).encode('hex')
```
`single byte xor`
**This is mainly bruteforceable**
>As we know `0x41^0x42 is 0x3` so 
```
for i in xrange(256):
	print xor(i,"41414141".decode('hex'))

```

`repeating-key`
```
xor("Burning 'em, if you ain't quick and nimble","ICE").encode('hex')
``` 
>This will sequentially apply XOR for each byte of the key; the first byte of plaintext will be XOR'd against I, the next C, the next E, then I again for the 4th byte, and so on.


# hex to Character to base64
```
$  echo 0x49276d206b696c6c696e67 | xxd -r | base64
```
or in python
```
import base64
base64.b64encode("49276d206b696c6c696e67".decode('hex'))
```

# Vigenere Cipher(Break repeating-key XOR)



# Tools

## Quipquip (https://quipqiup.com/)

**Online tool that will help you solve almost all subsituition cipher** 




# Fingerprinting(finding if code you are reading is any of)

## BASE 64

**(n >> 18) & 63, n2 = (n >> 12) & 63, n3 = (n >> 6) & 63, n4 = n & 63 .**

> so if you see `>> 18` and `>> 12` and `>> 6` and ` & 0x3f`, so it can be base64 .
